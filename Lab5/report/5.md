# FAT16 文件系统

### PB22151796 莫环欣

---

## 实验目的

## 实验环境

## 实验步骤

## 代码原理

### 读根目录

这里需要完成`fat16_readdir`与`fill_entries_in_sectors`两个函数

- `fat16_readdir`： 这里需要补充根目录情况下两个变量的赋值

  - 目的是从根目录的开始扇区往后扫描整个根目录扇区
  - 故直接将`meta`的`root_sec`和`root_sectors`两个成员赋出去即可
    ```c
    // TODO: 请填写正确的根目录区域开始扇区号，你可以参考 meta 的定义。
    sector_t first_sec = meta.root_sec;
    // TODO: 请填写正确的根目录区域扇区数
    size_t nsec = meta.root_sectors;
    ```

- `fill_entries_in_sectors`：这里需要补全当前的扇区号、扇区扫描的区间、目录名的长度转换

  - 由于是在`for`循环中，且有起始地址，故直接将起始地址加上循环变量赋值出去即可
  - 此外，每个扇区的大小可以从`meta`的成员中获取，每个目录项的大小也有定义
  - 转换为长名只需根据`to_long_name`函数的接口传入即可

    ```c
    // TODO: 每轮循环需要操作的扇区号
    sector_t sec = first_sec + i;

    // TODO:
    for(size_t off = 0; off < meta.sector_size; off += DIR_ENTRY_SIZE )

    // TODO: 请调用 to_longname 函数，将 entry->DIR_Name 转换为长文件名，结果放在 name 中
    int ret = to_longname(entry->DIR_Name, name, MAX_NAME_LEN);

    ```

### 读根目录下的短文件

这里需要完成两个函数

- `find_entry_in_sectors` ：
  - 仿照上面已经完成的`find_entries_in_sectors`函数即可
  - 从`from_sector`开始搜索`sectors_count`个扇区
    - 首先将整个扇区的内容读入缓存中
    - 接着对当前扇区中的所有目录项调用`check_name`函数进行检查
      - 若找到对应的目录项，直接返回`FIND_EXIST`
      - 若找到空槽，也直接返回`FIND_EMPTY`
    - 对所有扇区进行相同的检测操作
  - 若所有扇区都未能查找到目录项或空槽，返回`FIND_NULL`

```c
    for(size_t i=0; i < sectors_count; i++) {       // 搜索 sectors_count 个扇区
        sector_t sec = from_sector + i;             // 从 from_sector 开始搜索
        int ret = sector_read(sec, buffer);         // 读取扇区内容到缓存中
        if(ret < 0) {
            return -EIO;
        }
        /* 对单个扇区内的目录项进行搜索 */
        for(size_t off = 0; off < meta.sector_size; off += DIR_ENTRY_SIZE ) {
            DIR_ENTRY* entry = (DIR_ENTRY*)(buffer + off);
            if(de_is_valid(entry)) {    // 有效目录项
                // 将 filler 函数的调用改为check_name的检查
                // 无需调用to_longname， check_name中会自动处理
                if(check_name(name, len, entry)) {
                    // 找到匹配项
                    // 修改 slot 的三个属性
                    slot->dir = *entry;
                    slot->sector = sec;
                    slot->offset = off;
                    return FIND_EXIST;
                }
            }
            if(de_is_free(entry)) {
                // 由于找到空槽会直接返回
                // 所以空槽也要记录下来
                    slot->dir = *entry;
                    slot->sector = sec;
                    slot->offset = off;
                return FIND_EMPTY;
            }
        }
    }
```

- `read_from_cluster_at_offset` ：

  - 为了确保扇区内偏移量确实在扇区内，应该把传入的偏移量模扇区大小
  - 之后计算出需要复制的长度，每次调用`memcpy`复制合理长度的数据到缓存中，并更新已复制字节数
    - 循环操作，直到全部读取完毕

  ```c
  // TODO: 请填写正确的扇区内偏移量。
  size_t sec_off = offset % meta.sector_size;

  /*-----------------------------分割线-------------------------------------------*/

    /* 计算需要复制的长度，若当前扇区剩余长度不足，则需要全部复制后再搜索下一个扇区 */
    size_t copy_bytes = min(meta.sector_size - sec_off, size - pos);
    /* 将扇区偏移后的copy_bytes个字节数据复制到data + pos 位置 */
    memcpy(data + pos, sector_buffer + sec_off, copy_bytes);
    /* 更新已读取的字节数 */
    pos += copy_bytes;
  ```

### 创建根目录下的文件

此处需要补全两个函数

- `dir_entry_create` ：

  - 此出补全较为简单，将传入的参数全部赋给`dir`的成员即可

  ```c
  /* 把传入的参数全部对 DIR 赋值即可 */
  memcpy(dir->DIR_Name, shortname, FAT_NAME_LEN); // 使用 memcpy 函数来设置 DIR_Name
  dir->DIR_Attr = attr;            // 设置 DIR_Attr
  dir->DIR_FstClusHI = 0;          // 设置 DIR_FstClusHI （永远为0）
  dir->DIR_FstClusLO = first_clus; // 设置 DIR_FstClusLO
  dir->DIR_FileSize = file_size;   // 设置 DIR_FileSize
  ```

- `dir_entry_write` ：

  - 为了防止数据被破坏，先将数据从扇区中读入缓存
  - 接着在缓存对应的位置进行修改
  - 最后将缓存的内容应用到整个扇区

  ```c
  /* 传入： 扇区号， 缓存地址 */
  int ret = sector_read(slot.sector, sector_buffer);
  /* slot.offset 是当前已经使用的总长度 */
  /* 传入： 修改位置地址（缓存）， 修改来源地址， 修改量大小 */
  memcpy(sector_buffer + slot.offset, &(slot.dir), sizeof(DIR_ENTRY));
  /* 当前扇区的最新所有数据都在缓存中，应该全部写回 */
  /* 传入： 扇区号， 缓存地址 */
  ret = sector_write(slot.sector, sector_buffer);
  ```

### 读根目录下的长文件

- `read_fat_entry` ：
  - 给定簇号，获取并`FAT`表中对应的表项
  - 首先找到扇区和在扇区内的位置
  - 接着使用`sector_read`将扇区数据读入缓存中
  - 最后将缓存中对应位置的数据返回

```c
    /* 计算扇区号，每个FAT表项占用2字节 */
    sector_t sec = meta.fat_sec + clus / (meta.sector_size / 2);
    /* 计算扇区内偏移量 */
    size_t off = (clus % (meta.sector_size / 2)) * 2;
    /* 获取表项的大小 */
    int ret = sector_read(sec, sector_buffer);
    if(ret < 0) {
        return ret;
    }

    return *(cluster_t*)(sector_buffer + off);
```

- `fat16_read` ：
  - 该函数需要完成读取跨簇文件的部分
  - 可以循环进行，每次只读取合法范围数据
  ```c
  /* (还有数据需要读取) && 簇号有效 */
  while((p < size) && is_cluster_inuse(clus)) {
      /* min(不需要读取到簇末尾， 需要读取到簇末尾) */
      size_t Dread_len = min(size - p, meta.cluster_size - offset);   // Data_read_lenth
      /* 考虑到跨簇读取，应该写入缓存中实际已经写好的位置之后 */
      int ret = read_from_cluster_at_offset(clus, offset, buffer + p, Dread_len);
      if(ret < 0) {
          return ret;
      }
      /* p 自增本轮实际读取的长度 */
      p += ret;
      /* 读取一轮之后，下一簇必然是从起始位置开始访问的 */
      offset = 0;
      /* 更新clus */
      clus = read_fat_entry(clus);
  }
  ```

### 读取/创建非根目录下的文件

- `find_entry_internal` ：

  - 本函数需要完成查找非根目录路径的目录项的部分

  ```c
  state = find_entry_in_sectors(
            *remains,
            len,
            cluster_first_sector(clus),
            meta.sec_per_clus,
            slot
          );
  ```

### 创建目录

- `fat16_mkdir`：创建`path`对应的文件

  - 这里仿照创建文件函数`mknod`的结构即可，具体如下

  ```c
    /* 先找到一个空闲目录项 */
    ret = find_empty_slot(path, &slot, &filename);
    if(ret < 0) {
        return ret;
    }
    /* 将长文件名转化为短文件名 */
    char shortname[11];
    ret = to_shortname(filename, MAX_NAME_LEN, shortname);
    if(ret < 0) {
        return ret;
    }
    /* 准备工作完毕，分配一个空闲簇 */
    ret = alloc_one_cluster(&dir_clus);
    if(ret < 0) {
        return ret;
    }
    /* 创建目录项 */
    ret = dir_entry_create(slot, shortname, ATTR_DIRECTORY, dir_clus, 0);
    if(ret < 0) {
        return ret;
    }
  ```

- `write_fat_entry`：写入`FAT`表项

  - 这里在循环时先将扇区中的内容读取到缓存中，接着修改缓存对应偏移处的值，最后再将缓存中的数据写回扇区
    - 这是为了避免破坏数据

  ```c
  /* 计算第 i 个 FAT 表所在扇区，进一步计算clus对应的FAT表项所在扇区*/
  sector_t sec = meta.fat_sec + i * meta.sec_per_fat + clus_sec;
  int ret = sector_read(sec, sector_buffer); // 读取该扇区
  if(ret < 0) {
      return ret;
  }
  // *(cluster_t*)(sector_buffer + sec_off) = data;在对应位置修改数据
  memcpy(sector_buffer + sec_off, &data, sizeof(cluster_t));
  ret = sector_write(sec, sector_buffer); // 将该扇区写回
  if(ret < 0) {
      return ret;
  }
  ```

- `alloc_one_cluster`：分配一个空闲簇
  - 扫描整个`FAT`表，直到找到一个空闲簇为止
  ```c
    /* 扫描FAT表找一个空闲簇，从MIN扫到MAX*/
    cluster_t ClusN = CLUSTER_MIN;
    while(ClusN <= CLUSTER_MAX) {
        /* 找到空闲簇 */
        if (read_fat_entry(ClusN) == CLUSTER_FREE) {
            /* 记录簇号 */
            *clus = ClusN;
            /* 将FAT表项指向CLUSTER_END */
            write_fat_entry(*clus, CLUSTER_END);
            /* 清零 */
            cluster_clear(*clus);
            /* 返回 */
            return 0;
        }
        ClusN++;
    }
    /* 找不到 */
    return -ENOSPC;
  ```

### 删除文件/目录

- `fat16_unlink`：删除文件

  - 要删除一个文件，首先需要找到它，并且确认其属性是一个文件
  - 但是我们并不需要真的将其“删除”，只需要释放它占用的簇，并将其标记为删除即可

  ```c
    /* 找到目录项 */
    int ret = find_entry(path, &slot);
    if(ret < 0) {
        return ret;
    }
    /* 确认目录项是个文件 */
    if(attr_is_directory(dir->DIR_Attr)) {
        return -EISDIR;
    }
    /* 释放占用的簇 */
    free_clusters(dir->DIR_FstClusLO);
    /* 修改目录项为删除 */
    dir->DIR_Name[0] = NAME_DELETED;
    /* 写回目录项 */
    ret = dir_entry_write(slot);
  ```

- `fat16_rmdir`：删除目录

  - 与删除目录类似
    - 但删除目录还需要确保其为空
      - 即除了"."和".."外再无其余内容
      - 删除含有内容的文件夹，实际上就是递归调用这两个函数
  - 检查目录是否为空
    - 遍历目录占有的所有簇中的所有扇区
      - 这里与读目录类似
      - 区别在于，当检查到扇区中的目录项时：
        - 检查目录项是否为空
        - 若为空，跳过
        - 若不为空
          - 检查是否为"."或".."
            - 若不是，说明目录不为空，返回错误
    - 遍历完当前簇之后，通过读取`FAT`表项进入相连的下一个簇
  - 确保目录为空之后，进行删除操作
    - 首先，调用函数释放目录占用的所有簇
    - 接着，将文件标记为删除
      - 这里也需要先读取、修改、写回

  ```c
    // 检查是否合法**********************************************
    cluster_t clus = CLUSTER_END;
    DirEntrySlot slot;
    /* 找到目录项 */
    int ret = find_entry(path, &slot);
    if(ret < 0) {
        return ret;
    }
    DIR_ENTRY* dir = &(slot.dir);
    /* 若不是目录，返回错误 */
    if(!attr_is_directory(dir->DIR_Attr)) {
        return -ENOTDIR;
    }

    // 检查目录是否为空******************************************

    /* 从目录项中获取簇号 */
    clus = dir->DIR_FstClusLO;

    while(is_cluster_inuse(clus)) {
        /* 从簇的第一个扇区开始扫描 */
        sector_t fst_clus_sec = cluster_first_sector(clus);
        /* 获取扇区总数 */
        size_t nsec = meta.sec_per_clus;
        char sector_buffer[MAX_LOGICAL_SECTOR_SIZE];
        /* 遍历扇区 */
        for (size_t i = 0; i < nsec; i++){
            /* 当前操作扇区 */
            sector_t sec = fst_clus_sec + i;
            /* 读入缓存 */
            int ret = sector_read(sec, sector_buffer);
            if(ret < 0) {
                return -EIO;
            }
            /* 检查每一个目录项 */
            for (size_t off = 0; off < meta.sector_size; off += DIR_ENTRY_SIZE) {
                /* buffer中存储了扇区中的全部数据，每次检查一个目录项 */
                DIR_ENTRY* entry = (DIR_ENTRY*)(sector_buffer + off);
                /* 目录不为空 */
                if(de_is_valid(entry)) {
                    /* 不是 . 或 ..  */
                    if (!de_is_dot(entry)) {
                        return -ENOTEMPTY;
                    }
                }
            }
        }
        /* 进入目录的下一个簇 */
        clus = read_fat_entry(clus);
    }
    /* 释放目录的簇 */
    free_clusters(dir->DIR_FstClusLO);
    /* 标记为删除 */
    char buff[MAX_LOGICAL_SECTOR_SIZE];
    dir->DIR_Name[0] = NAME_DELETED;
    /* 读出、修改、写回 */
    sector_read(slot.sector, buff);
    memcpy(buff + slot.offset, &(slot.dir), DIR_ENTRY_SIZE);
    sector_write(slot.sector, buff);
  ```

### 写入文件

由于近期为考试月，许多科目需要补天，且之前`删除文件/目录`部分尚未完成，故该部分一直拖着没做，截至写报告时（2024/6/7 ; 20:24）刚完成基础的代码逻辑编写，debug 的助教处有很多人排队，因此决定放弃该部分。但**写都写了**，还是展示一下部分逻辑（感觉大体应该是对的）

- `fat16_write`：将数据写入到文件中
  - 首先检查是否需要分配新的簇
    - 先遍历文件的`FAT`表，获取其最后一个簇号与占用簇数
    - 接着判断加上需要写入内容的大小后是否大于已分配大小
      - 若大于，则新分配合适数量的簇
      - 分配好后，将新分配的簇连接到已有的`FAT`表里
  - 空间检查完毕后，将数据写入对应的偏移处
    - 先移动簇号到偏移开始簇
    - 接着计算应该写入这个簇中的偏移量
    - 若这个簇无法写入全部内容，则进入下一个簇继续写
  - 最后将更新后的文件写回即可
- `write_to_cluster_at_offset`： 在指定的偏移位置处写入内容
  - 先计算出需要写入的扇区与扇区内偏移量
  - 同样，分多次将内容写入扇区（可能有多个）中
    - 一样需要读出、修改、写回
  - 最后返回成功写入的字节数
- `alloc_clusters`：
  - 先扫描`FAT`表，直到找到`n`个空闲簇
  - 接着将最后一个簇设置为尾部
  - 再将所有簇依次相连，并清空每个簇的内容
  - 最后将分配的收个簇返回

## 其它信息

FAT16 的主要优点是兼容性最好，某些数码设备可能对 FAT32 和 NTFS 格式的存储卡支持不太好，因此只能使用 FAT16。然而，FAT16 的主要缺点是最大仅支持 2GB 分区，空间浪费大

"扇区"和"簇"都是计算机硬盘存储的基本单位，它们的命名与它们的功能和形状有关。

- **扇区（Sector）**：扇区是磁盘最小的物理存储单元。每个磁盘都被分为多个相同大小的扇区，这样可以方便地读取和写入数据。扇区的名称来源于它的形状，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分。每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区。

- **簇（Cluster）**：由于扇区的空间比较小且数目众多，在寻址时比较困难，所以操作系统就将多个的扇区组合在一起，形成一个更大的单位，再对这个单位进行整体的操作。这个单位，在 Windows 下，FAT，FAT32 和 NTFS 文件系统中叫做簇（cluster）；在 Linux 下如 Ext4 等文件系统中叫做块（block）。"簇"这个词在汉语中有“一群”、“一组”的意思，这与它在计算机中的含义相吻合，因为一个簇包含了多个扇区。

在 Ubuntu 22.04 中，可以使用`gnome-terminal`来打开一个新的终端窗口，并在其中执行命令。在脚本中添加以下命令：

```bash
gnome-terminal -- bash -c "cat a; exec bash"
```

这条命令会做以下几件事：

- `gnome-terminal`：打开一个新的`gnome-terminal`窗口。
- `--`：告诉`gnome-terminal`后面的内容不是选项，而是要执行的命令。
- `bash -c`：在新的`bash` Shell 中执行后面的命令。
- `"cat a; exec bash"`：首先执行`cat a`命令，然后通过`exec bash`保持新的 Shell 打开。
